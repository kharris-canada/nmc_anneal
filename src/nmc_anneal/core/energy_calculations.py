"""Calculate electrostatic energies for atoms in NMC structures.

Provides functions to compute metal redox energies and oxygen layer energies
based on Coulomb interactions between charged atoms in the 3D lattice structure.
Accounts for periodic boundary conditions and oxygen sublattice positions.
"""

import numpy as np
from numpy.typing import NDArray

# Type alias for charges lattices (dtype=np.int8)
ChargesLattice = NDArray[np.int8]

# there's at tiny bit of added overhead here in that we're checking for translational symmetry corrections on every single index in sum
# could save time by manually summing over matrix edge rows (which require corrections with modulo) and then entire center (no corrections)
# but, we don't calculate total energy often, it's the annealing that is the bottleneck and that has different calculation logic
# so simplifying code instead


def _single_oxygen_energy(
    lattice_width: int,
    lattice_charges: ChargesLattice,
    index: tuple[int, int, int],
) -> float:
    """
    Calculate the energy of a single oxygen atom in the virtual oxygen matrix:
    need to figure out indices of all 6 TM around it using translational symmetry
    since all TM around generated by shifts, just need to do shifts with modulo math set to width or height
    These are all geometric relationships, see a 3D diagram to understand them

    Args:
        lattice_width (int): Width of the square 2D layers.
        lattice_charges (ChargesLattice): 3D array of all charges in structure with proper geometry.
        index (tuple[int, int, int]): Location of the oxygen atom as (layer_index, x, y).

    Returns:
        float: Electrostatic energy of the oxygen atom at the specified location.
    """

    # metals down one layer from this virtual oxygen layer are by definition not outside the box in the height dimension
    # but could be outside x or y, so only use modulo math to fix coord 1,2, not coord 0
    metal1 = lattice_charges[(index[0], index[1], index[2])]
    metal2 = lattice_charges[(index[0], index[1], (index[2] + 1) % lattice_width)]
    metal3 = lattice_charges[(index[0], (index[1] + 1) % lattice_width, index[2])]

    # metals up one layer could be outside x or y
    # If working on full stack, metals might be off the top of the bounding box too, so need to correct with modulo function
    up_layer = (index[0] + 1) % lattice_charges.shape[0]
    metal4 = lattice_charges[(up_layer, index[1], index[2])]
    metal5 = lattice_charges[(up_layer, index[1], (index[2] - 1) % lattice_width)]
    metal6 = lattice_charges[(up_layer, (index[1] - 1) % lattice_width, index[2])]

    return float((metal1 + metal2 + metal3 + metal4 + metal5 + metal6) / 6 - 2)


def single_metal_energy(
    lattice_width: int,
    lattice_charges: ChargesLattice,
    index: tuple[int, int, int],
) -> float:
    """
    Calculates the energy of a single metal (transition metal or lithium atom).

    This is tricky. Need to define all the oxygen atoms in the virtual oxygen lattice. See notes at start and
    also see notes in single_oxygen_energy to see geometry description used here

    Convention here is oxygen layers are *one index less* than a given layer and equal index to that metal layer


    Args:
        lattice_width (int): Width of the square 2D layers.
        lattice_charges (ChargesLattice): 3D array of all charges in structure with proper geometry.
        index (tuple[int, int, int]): Location of the metal atom as (layer_index, x, y).

    Returns:
        float: Total electrostatic energy of the metal atom at the specified location.
    """

    # Oxygen atoms might be outside bounding box if layer 0 of metal lattice:
    down_layer = (index[0] - 1) % lattice_charges.shape[0]
    oxygen1 = (down_layer, index[1], index[2])
    oxygen2 = (down_layer, index[1], (index[2] + 1) % lattice_width)
    oxygen3 = (down_layer, (index[1] + 1) % lattice_width, index[2])

    # Only need to correct for changes and periodicity in horizontal dimension
    up_layer = index[0]
    oxygen4 = (up_layer, index[1], index[2])
    oxygen5 = (up_layer, index[1], (index[2] - 1) % lattice_width)
    oxygen6 = (up_layer, (index[1] - 1) % lattice_width, index[2])

    energy_sum = 0.0
    for virtual_oxygen_coord in [oxygen1, oxygen2, oxygen3, oxygen4, oxygen5, oxygen6]:
        energy_sum += abs(
            _single_oxygen_energy(lattice_width, lattice_charges, virtual_oxygen_coord)
        )

    return round(energy_sum, 5)


def single_metal_redox(
    proposed_charge: int,
    lattice_charges: ChargesLattice,
    index: tuple[int, int, int],
) -> float:
    """
    Calculates the energy of a single metal going from its charge listed in lattice_charges and changing to the proposed charge.
    That depends on the 6 nearest oxygen atoms (and their metal partners)


    Args:
        proposed_charge (int): Target charge state for the redox change.
        lattice_charges (ChargesLattice): 3D array of all charges in structure with proper geometry.
        index (tuple[int, int, int]): Location of the metal atom as (layer_index, x, y).

    Returns:
        float: Energy change from transitioning to the proposed charge state (negative indicates favorable).
    """

    lattice_width = lattice_charges.shape[1]

    # Addresses of the 6 nearest atoms:
    # Need to correct for periodicity including if atoms might be outside bounding box if layer 0 of metal lattice:
    down_layer = (index[0] - 1) % lattice_charges.shape[0]
    oxygen1 = (down_layer, index[1], index[2])
    oxygen2 = (down_layer, index[1], (index[2] + 1) % lattice_width)
    oxygen3 = (down_layer, (index[1] + 1) % lattice_width, index[2])

    # Still need to make sure we correct for periodicity in the horizontal dimension
    up_layer = index[0]
    oxygen4 = (up_layer, index[1], index[2])
    oxygen5 = (up_layer, index[1], (index[2] - 1) % lattice_width)
    oxygen6 = (up_layer, (index[1] - 1) % lattice_width, index[2])

    # Calculate energy of all involved oxygen atoms before swap
    energy_sum_before_swap = 0.0
    for virtual_oxygen_coord in [oxygen1, oxygen2, oxygen3, oxygen4, oxygen5, oxygen6]:
        energy_sum_before_swap += abs(
            _single_oxygen_energy(lattice_width, lattice_charges, virtual_oxygen_coord)
        )

    # Swap atom to new charge, calculate all relevant oxygen energies, then swap charge back
    original_charge = lattice_charges[(index[0], index[1], index[2])]
    lattice_charges[(index[0], index[1], index[2])] = proposed_charge
    energy_sum_after_swap = 0.0

    for virtual_oxygen_coord in [oxygen1, oxygen2, oxygen3, oxygen4, oxygen5, oxygen6]:
        energy_sum_after_swap += abs(
            _single_oxygen_energy(lattice_width, lattice_charges, virtual_oxygen_coord)
        )

    lattice_charges[(index[0], index[1], index[2])] = original_charge

    # With this definition, energy_change is a +ve number if swap is good
    energy_change = energy_sum_before_swap - energy_sum_after_swap

    return round(energy_change, 5)


def average_all_oxygen_energies(lattice_charges: ChargesLattice) -> float:
    """
    Sum over all N layers of the virtual oxygen array implied by the metals in lattice_charges
    (oxygen array starts with layer 0 between metal layers 0 and 1 and goes until one layer above final TM so it's periodic)

    Args:
        lattice_charges (ChargesLattice): 3D array of all charges in the complete structure.

    Returns:
        float: Average electrostatic energy per oxygen atom in the lattice.

    Raises:
        ValueError: If attempt is made to use on partial lattice, return value error

    Returns:
        float: Average energy over all oxygen atoms in lattice_charges
    """

    tot_layers = lattice_charges.shape[0]  # 2 x config.n_layers
    width = lattice_charges.shape[1]

    if (tot_layers % 2) != 0:
        raise ValueError(
            "average_all_oxygen_energies() is designed for the full lattice stack."
            "For 3-layer pieces, use one_metal_layer_oxygen_energies()"
        )

    energy_count = float(0)
    # Need to check if range needs start,(end+1)
    for i in range(0, tot_layers):
        for j in range(0, width):
            for k in range(0, width):
                energy_count += abs(
                    _single_oxygen_energy(width, lattice_charges, (i, j, k))
                )

    return float(energy_count / (width * width * tot_layers))


def one_metal_layer_oxygen_energies(lattice_charges: ChargesLattice) -> float:
    """
    Sum over the two oxygen virtual layers on the two sides of one metal layer (TM or Li).
    (but must know the charges of the two metal layers on either side of each to calculate these oxygen layers so it's a 3-metal slab)

    Args:
        lattice_charges (ChargesLattice): 3D array containing exactly 3 metal layers with proper geometry.

    Returns:
        float: Average electrostatic energy per oxygen atom in the 3-layer slab.

    Raises:
        ValueError: If attempt is made to use on full lattice, return value error

    Returns:
        float: Average energy over all oxygen atoms in the partial lattice contained in lattice_charges
    """

    tot_layers = lattice_charges.shape[0]  # 2 x config.n_layers
    width = lattice_charges.shape[1]

    if (tot_layers % 2) != 1:
        raise ValueError(
            "Function one_metal_layer_oxygen_energies() is for 3-layer pieces."
            "For the full lattice stack, use average_all_oxygen_energies()"
        )

    energy_count = float(0)
    for i in [0, 1]:
        for j in range(0, width):
            for k in range(0, width):
                energy_count += abs(
                    _single_oxygen_energy(width, lattice_charges, (i, j, k))
                )

    return float(energy_count / (width * width * 2))


def energy_swap_two_metals(
    lattice_width: int,
    lattice_charges: ChargesLattice,
    index_metal1: tuple[int, int, int],
    index_metal2: tuple[int, int, int],
) -> float:
    """
    Calculate the energy change from swapping two metal atoms' charges in the lattice.

    Temporarily exchanges the charges of two metals and recalculates their electrostatic
    energies to determine whether the swap is energetically favorable.

    Args:
        lattice_width (int): Width of the square 2D layers.
        lattice_charges (ChargesLattice): 3D array of all charges in structure with proper geometry.
        index_metal1 (tuple[int, int, int]): Location of first metal as (layer_index, x, y).
        index_metal2 (tuple[int, int, int]): Location of second metal as (layer_index, x, y).

    Returns:
        float: Energy change from the swap (negative indicates favorable change).
    """
    # before swap:
    energy_atom1_preswap = single_metal_energy(
        lattice_width, lattice_charges, index_metal1
    )
    energy_atom2_preswap = single_metal_energy(
        lattice_width, lattice_charges, index_metal2
    )

    # Temporarily swap the charges
    orig_index1 = lattice_charges[index_metal1]
    orig_index2 = lattice_charges[index_metal2]
    lattice_charges[index_metal1] = orig_index2
    lattice_charges[index_metal2] = orig_index1

    # after temporary swap:
    energy_atom1_postswap = single_metal_energy(
        lattice_width, lattice_charges, index_metal1
    )
    energy_atom2_postswap = single_metal_energy(
        lattice_width, lattice_charges, index_metal2
    )

    # Reverse the temporary swap
    lattice_charges[index_metal1] = orig_index1
    lattice_charges[index_metal2] = orig_index2

    energy_of_swap = (energy_atom1_postswap + energy_atom2_postswap) - (
        energy_atom1_preswap + energy_atom2_preswap
    )

    return energy_of_swap
