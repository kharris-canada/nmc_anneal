from pathlib import Path
import numpy as np

from nmc_anneal import SimulationConfig
from nmc_anneal import anneal_3Dlattice
import nmc_anneal.viz.gridplots as gridplots


def find_and_plot_convergence(
    config: SimulationConfig,
    whole_lattice_charges: np.ndarray,
    whole_lattice_species: np.ndarray,
    output_filename: str,
    anneal_type: str,
    max_n_steps: int,
    sim_hot_temp: float,
    sim_cold_temp: float,
    fraction_max_steps_list: np.ndarray,
):
    """
    Reads in: parameters and existing lattice (expected to match SimulationConfig variables)
    Anneals for a range of numbers of steps and generates an output pdf file with results
    Lattice generated by each annealing run is discarded
    NOTE: you can view the output pdf before all runs are done
    """
    if len(fraction_max_steps_list) > 8:
        raise ValueError(
            f"Automatic plotting of convergence only works for up to 9 simulation lengths. "
        )

    VALID_ANNEAL_TYPES = {
        "TM Convergence Check",
        "Li Convergence Check",
    }

    if anneal_type not in VALID_ANNEAL_TYPES:
        raise ValueError(
            f"Invalid anneal_type: '{anneal_type}'. "
            f"Must be one of: {', '.join(sorted(VALID_ANNEAL_TYPES))}"
        )

    config.curr_conv_check_max_n_steps = max_n_steps
    config.curr_conv_check_hot_temp = sim_hot_temp
    config.curr_conv_check_cold_temp = sim_cold_temp

    trajectories = []
    step_counts = []
    final_avg_energies = []

    starting_lattice_charges = whole_lattice_charges.copy()
    starting_lattice_species = whole_lattice_species.copy()

    for fraction_max_steps in fraction_max_steps_list:
        config.curr_conv_check_n_steps = round(fraction_max_steps * max_n_steps)

        whole_lattice_charges = starting_lattice_charges.copy()
        whole_lattice_species = starting_lattice_species.copy()

        energy_trajectory = anneal_3Dlattice(
            config,
            whole_lattice_charges,
            whole_lattice_species,
            anneal_type,
            graph_energy=True,
        )

        last_5_percent_start = int(95 * (len(energy_trajectory) / 100))
        avg_final_energy = np.mean(energy_trajectory[last_5_percent_start:])

        trajectories.append(energy_trajectory)
        step_counts.append(config.curr_conv_check_n_steps)
        final_avg_energies.append(avg_final_energy)

        gridplots.plot_energy_convergence_grid(
            config,
            anneal_type,
            trajectories,
            step_counts,
            final_avg_energies,
            output_filename,
        )
